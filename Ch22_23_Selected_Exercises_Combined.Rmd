---
title: "R for Data Science - Chapters 22 & 23 Exercises"
output:
  pdf_document:
    latex_engine: xelatex
    toc: true
    number_sections: true
    keep_tex: true
---



## Chapter 22.5.3 Exercises - Using dplyr with Arrow

### 1. Figure out the most popular book each year

```r
library(arrow)
library(dplyr)

seattle_pq <- open_dataset("path_to_parquet_files")

most_popular_books <- seattle_pq |>
  filter(MaterialType == "BOOK") |>
  group_by(CheckoutYear, Title) |>
  summarize(TotalCheckouts = sum(Checkouts), .groups = "drop") |>
  arrange(CheckoutYear, desc(TotalCheckouts)) |>
  group_by(CheckoutYear) |>
  slice_max(TotalCheckouts, n = 1) |>
  collect()

most_popular_books
```

### 2. Which author has the most books in the Seattle library system?

```r
top_authors <- seattle_pq |>
  filter(MaterialType == "BOOK") |>
  group_by(Creator) |>
  summarize(TotalCheckouts = sum(Checkouts), .groups = "drop") |>
  arrange(desc(TotalCheckouts)) |>
  slice_max(TotalCheckouts, n = 1) |>
  collect()

top_authors
```

### 3. How has checkouts of books vs ebooks changed over the last 10 years?

```r
checkout_trends <- seattle_pq |>
  filter(CheckoutYear >= (max(CheckoutYear) - 10),
         MaterialType %in% c("BOOK", "EBOOK")) |>
  group_by(CheckoutYear, MaterialType) |>
  summarize(TotalCheckouts = sum(Checkouts), .groups = "drop") |>
  collect()

checkout_trends
```

## Chapter 23.3.5 Exercises - Unnesting List Columns

### 1. What happens when you use `unnest_wider()` with unnamed list-columns like df2?

```r
library(tibble)
library(tidyr)

df2 <- tribble(
  ~x, ~y,
  1, list(11, 12, 13),
  2, list(21),
  3, list(31, 32)
)

# Attempt unnest_wider
df2 |> unnest_wider(y)
# You'll need to supply `names_sep` or handle naming since lists are unnamed.
```

### 2. What happens when you use `unnest_longer()` with named list-columns like df1?

```r
df1 <- tribble(
  ~x, ~y,
  1, list(a = 11, b = 12),
  2, list(a = 21, b = 22),
  3, list(a = 31, b = 32)
)

df1 |> unnest_longer(y)
# Extra detail: an index column is added. Use `indices_include = FALSE` to suppress it.
```

### 3. Multiple aligned list-columns: what happens with two `unnest_longer()` calls?

```r
df4 <- tribble(
  ~x, ~y, ~z,
  "a", list("y-a-1", "y-a-2"), list("z-a-1", "z-a-2"),
  "b", list("y-b-1", "y-b-2", "y-b-3"), list("z-b-1", "z-b-2", "z-b-3")
)

# This works because tidyr will automatically preserve alignment if you unnest both at once:
df4 |> unnest_longer(y) |> unnest_longer(z)

# To preserve alignment, unnest both together:
df4 |> unnest_longer(c(y, z))
```

### Notes
- Use `indices_include = FALSE` to suppress indexing from named lists.
- When unnested together, aligned columns retain row pairing.

## Chapter 23.5.4 Exercises - Working with JSON in R

### Rectangle the `df_col` and `df_row` JSON objects

```r
library(tibble)
library(tidyr)
library(jsonlite)

# JSON with columns as keys
json_col <- parse_json('{
  "x": ["a", "x", "z"],
  "y": [10, null, 3]
}')

# JSON as an array of row objects
json_row <- parse_json('[
  {"x": "a", "y": 10},
  {"x": "x", "y": null},
  {"x": "z", "y": 3}
]')

# Convert column-style JSON
df_col <- tibble(json = list(json_col))
df_col |> unnest_wider(json)
```

```r
# Convert row-style JSON
df_row <- tibble(json = json_row)
df_row |> unnest_wider(json)
```

### Notes
- `df_col` represents column-major encoding; each key maps to a full column.
- `df_row` uses row-major encoding, with each item representing a record.
- Both are valid JSON formats for data frames but require different handling in `tidyr`.